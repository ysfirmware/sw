#include <string.h>#include <stdio.h>#include "serial_flash.h"#include "gpiodef.h"#include "util.h"#include "spidef.h"#include "uartproc.h"byte D_Model_Name[9];			// LCD 창에 표현될 Model명byte D_Model_Descript[32];		// LCD 창에 표현될 Full Model명byte D_Model_CS[2];				// LCD 창에 표현될 Model Binary Code의 Check-Sum Codebyte D_Model_Prog_Info[31];		// Program 정보 = Block별 Write 유무 판단함
byte r_WRd0FPAddr[4];
byte r_WRd0FPageData[10];
byte r_RDd0FPageData[10];
byte r_RDd0FPAddr[4];// ** Serial Flash 관련 변수 전역처리하고 공용화 함byte SF_Status;byte SF_Ret_Try;byte uc_INT_FID[3];/*void INT_SW_SPIDelay(void){	byte ucDelayCnt1 = 5;	//reset loop counter	while (ucDelayCnt1--) ;}*/void INT_FLASH_CS(uint8_t ucON){	if (ucON == _INT_FLASH_CS_ON_)	{		SetIO(IO_ROM_CS_PORT, IO_ROM_CS_PIN ,0);		SetIO(IO_TEMP_CS_PORT, IO_TEMP_CS_PIN ,1); // 둘중 하나만 	}	else	{		SetIO(IO_ROM_CS_PORT, IO_ROM_CS_PIN ,1);	}	delay_us(1);}void INT_FLASH_READ_ID(void){	//uint8_t ucID[3];	INT_FLASH_CS(_INT_FLASH_CS_ON_);	SPI_WriteByte(ROM_SPI,_FCMD_RD_JEDEC_ID_);	uc_INT_FID[0] = SPI_ReadByte(ROM_SPI);	uc_INT_FID[1] = SPI_ReadByte(ROM_SPI);	uc_INT_FID[2] = SPI_ReadByte(ROM_SPI);	delay_us(1);	INT_FLASH_CS(_INT_FLASH_CS_OFF_);	delay_us(10);		// Write Status Register Cycle Time = Typ:10ms MAX:15ms	// 0x1C, 0x30, 0x17	printf( " ** INT_FLASH_ID:[0x%02x],[0x%02x],[0x%02x]\r\n", uc_INT_FID[0], uc_INT_FID[1], uc_INT_FID[2]);	delay_us(100);}void FWrite_Status_REG(byte ucREG){	INT_FLASH_CS(_INT_FLASH_CS_ON_);	SPI_WriteByte(ROM_SPI,_FCMD_WR_Status_);	SPI_WriteByte(ROM_SPI,ucREG);	delay_us(1);	INT_FLASH_CS(_INT_FLASH_CS_OFF_);	delay_ms(10);		// Write Status Register Cycle Time = Typ:10ms MAX:15ms}byte FCheck_Status_REG(void){	//word ucStatus;	byte ucStatus;	//SF_Status = 0;		// Status Initial	//delay_us(5);	INT_FLASH_CS(_INT_FLASH_CS_ON_);	//delay_us(1);	SPI_WriteByte(ROM_SPI,_FCMD_RD_Stuatus_);	ucStatus = SPI_ReadByte(ROM_SPI);	//SF_Status = SPI_ReadByte();	delay_us(1);	INT_FLASH_CS(_INT_FLASH_CS_OFF_);	//delay_us(5);	return ucStatus;	//return SF_Status;}void INT_FLASH_SW_Reset(void){	INT_FLASH_CS(_INT_FLASH_CS_ON_);	SPI_WriteByte(ROM_SPI, _FCMD_WR_RST_);	INT_FLASH_CS(_INT_FLASH_CS_OFF_);	delay_ms(1);	INT_FLASH_CS(_INT_FLASH_CS_ON_);	SPI_WriteByte(ROM_SPI, _FCMD_WR_RST_EN_);	INT_FLASH_CS(_INT_FLASH_CS_OFF_);	delay_ms(1);}void INT_FLASH_SW_Reset_SEQ(void){	for(SF_Ret_Try=0; SF_Ret_Try<255; SF_Ret_Try++)	{		INT_FLASH_SW_Reset();		SF_Status = FCheck_Status_REG();		//if (SF_Status != 0x00)		// NOT RST Complete		if ((SF_Status & _F_SRWD_WIP) == _F_SRWD_WIP)		{			delay_ms(1);			if (SF_Ret_Try >= 100)			{				printf( "fRST_FAIL:[%d]:0x%02x\r\n", SF_Ret_Try, SF_Status);				return; 	// <y120217A>			}		}		else		{			//printf( "F-RST OK:[%d]:0x%02x\r\n", SF_Ret_Try, SF_Status);			break;		}	}}void FChip_Write_Enable(void){	//delay_us(1);	INT_FLASH_CS(_INT_FLASH_CS_ON_);	//delay_us(1);	SPI_WriteByte(ROM_SPI, _FCMD_WR_Eable_);		// Write Enable	delay_us(1);	INT_FLASH_CS(_INT_FLASH_CS_OFF_);	delay_ms(1);}void FChip_Write_Disable(void){	//delay_us(5);	INT_FLASH_CS(_INT_FLASH_CS_ON_);	//delay_us(1);	SPI_WriteByte(ROM_SPI,_FCMD_WR_Disable_);		// Write Disable	delay_us(1);	INT_FLASH_CS(_INT_FLASH_CS_OFF_);	delay_ms(1);}void FSector_Erase_Flash(void){	SF_Status = 0;		// Status Initial	for(SF_Ret_Try=0; SF_Ret_Try<255; SF_Ret_Try++)	{		SF_Status = FCheck_Status_REG();		if ((SF_Status & _F_SRWD_WEL) != _F_SRWD_WEL)		{			delay_ms(1);			if (SF_Ret_Try >= 100)			{				printf( "fsec_Wait1:[%x]:%x\r\n", SF_Ret_Try, SF_Status);				return;		// <y120217A>			}		}		else		{			break;		}	}	delay_us(3);	INT_FLASH_CS(_INT_FLASH_CS_ON_);	//delay_us(3);	SPI_WriteByte(ROM_SPI,_FCMD_Sector_Erase_);	SPI_WriteByte(ROM_SPI,r_WRd0FPAddr[0]);			// ADDRESS A23~16	SPI_WriteByte(ROM_SPI,r_WRd0FPAddr[1]);			// ADDRESS A15~8	SPI_WriteByte(ROM_SPI,r_WRd0FPAddr[2]);			// ADDRESS A7~0	delay_us(1);	INT_FLASH_CS(_INT_FLASH_CS_OFF_);	//for(SF_Ret_Try=0; SF_Ret_Try<50; SF_Ret_Try++)	//{		//delay_ms(1);	//}	delay_ms(50);	SF_Status = 0;		// Status Initial	for(SF_Ret_Try=0; SF_Ret_Try<30; SF_Ret_Try++)	{		SF_Status = FCheck_Status_REG();		if ((SF_Status & _F_SRWD_WIP) == _F_SRWD_WIP)		{			//delay_ms(200);			delay_ms(3);			if (SF_Status >= 100)			{				printf("fsec_Wait2:[%x]:%x\r\n", SF_Status, SF_Status);								return;		// <y120217A>			}		}		else		{			break;		}	}}void FChip_Erase_Flash(void){	//byte fe_Wait;	//byte fe_Status;	SF_Status = 0;		// Status Initial	//for(fe_Wait=0; fe_Wait<255; fe_Wait++)	for(SF_Ret_Try=0; SF_Ret_Try<255; SF_Ret_Try++)	{		SF_Status = FCheck_Status_REG();		if ((SF_Status & _F_SRWD_WEL) != _F_SRWD_WEL)		{			delay_ms(1);			//if (fe_Wait == 255)			if (SF_Ret_Try >= 100)			{				//sprintf(uart2buf , "fe_Wait1:[%x]:%x\r\n", fe_Wait, fe_Status);				printf( "fe_Wait1:[%x]:%x\r\n", SF_Ret_Try, SF_Status);								return;		// <y120217A>			}		}		else		{			break;		}	}	delay_us(3);	INT_FLASH_CS(_INT_FLASH_CS_ON_);	//delay_us(3);	SPI_WriteByte(ROM_SPI,_FCMD_Chip_Erase_);	delay_us(3);	INT_FLASH_CS(_INT_FLASH_CS_OFF_);	// SPEC:30s~50s	for(SF_Ret_Try=0; SF_Ret_Try<29; SF_Ret_Try++)	{		delay_ms(1000);	}	SF_Status = 0;		// Status Initial	//for(fe_Wait=0; fe_Wait<255; fe_Wait++)	for(SF_Ret_Try=0; SF_Ret_Try<255; SF_Ret_Try++)	{		SF_Status = FCheck_Status_REG();		if ((SF_Status & _F_SRWD_WIP) == _F_SRWD_WIP)		{			delay_ms(100);			if (SF_Status >= 250)			{				//sprintf(uart2buf , "fe_Wait2:[%x]:%x\r\n", fe_Wait, fe_Status);				printf( "fe_Wait2:[%x]:%x\r\n", SF_Status, SF_Status);								return;		// <y120217A>			}		}		else		{			break;		}	}}void Erase_Sector_Serial_Flash(void){	printf( "Sec-Ers-F: \r\n");	delay_us(10);	//outb(p_ROM_WP, 0);	FChip_Write_Enable();	// to do [Sector-Erase] code...	FSector_Erase_Flash();	//delay_ms(1);	//Status = Check_Erase_Flash();	FChip_Write_Disable();	delay_us(10);}void FProg_Page_Serial_Flash(void){	word addr;	//sprintf(uart2buf , "Write-F:%x-%x-%x-%x\r\n", r_WRd0FPAddr[0], r_WRd0FPAddr[1], r_WRd0FPAddr[2], r_WRd0FPageData[0]);	//sprintf(uart2buf , "Write-F: \r\n");	//SendRS232(uart2buf);// <y110503B>	delay_us(20);	//outb(p_ROM_WP, 0);	FChip_Write_Enable();	SF_Status = 0;		// Status Initial	//for(fp_Wait=0; fp_Wait<255; fp_Wait++)	for(SF_Ret_Try=0; SF_Ret_Try<255; SF_Ret_Try++)	{		SF_Status = FCheck_Status_REG();		if ((SF_Status & _F_SRWD_WEL) != _F_SRWD_WEL)		{			delay_ms(1);			//if (fp_Wait == 255)			if (SF_Ret_Try >= 100)			{				//sprintf(uart2buf , "fp_Wait1:[%x]:%x\r\n", fp_Wait, fp_Status);				printf( "fp_Wait1:[%x]:%x\r\n", SF_Ret_Try, SF_Status);				return;		// <y120217A>			}		}		else		{			break;		}	}	// ===============================================	INT_FLASH_CS(_INT_FLASH_CS_ON_);	//delay_us(3);	// to do [Page-Program] code...		1.3ms~5ms	SPI_WriteByte(ROM_SPI,_FCMD_Page_Prog_); //( ContinueArrayRead); // OPCODE	SPI_WriteByte(ROM_SPI,r_WRd0FPAddr[0]);			// ADDRESS A23~16	SPI_WriteByte(ROM_SPI,r_WRd0FPAddr[1]);			// ADDRESS A15~8	SPI_WriteByte(ROM_SPI,r_WRd0FPAddr[2]);			// ADDRESS A7~0	//SPI_WriteByte( 0x00);	// Dummy	for ( addr = 0 ; addr < _FData_Page; addr ++)	{		SPI_WriteByte(ROM_SPI,r_WRd0FPageData[addr]);		//asm volatile ("nop");		//INT_SW_SPIDelay();	}	delay_us(1);	INT_FLASH_CS(_INT_FLASH_CS_OFF_);	delay_ms(1);	// ===============================================	SF_Status = 0;		// Status Initial	//for(fp_Wait=0; fp_Wait<255; fp_Wait++)	for(SF_Ret_Try=0; SF_Ret_Try<255; SF_Ret_Try++)	{		SF_Status = FCheck_Status_REG();		if ((SF_Status & _F_SRWD_WIP) == _F_SRWD_WIP)		{			//delay_ms(1);			delay_us(30);			//if (fp_Wait == 255)			if (SF_Ret_Try >= 200)			{				//sprintf(uart2buf , "fp_Wait2:[%x]:%x\r\n", fp_Wait, fp_Status);				printf( "fp_Wait2:[%x]:%x\r\n", SF_Ret_Try, SF_Status);								return;		// <y120217A>			}		}		else		{			break;		}	}	FChip_Write_Disable();	delay_us(1);	//memset(r_WRd0FPageData , 0xFF , sizeof( r_WRd0FPageData));}void FRead_Page_Serial_Flash(void){	word addr;	INT_FLASH_CS(_INT_FLASH_CS_ON_);	//delay_us(2);	memset(r_RDd0FPageData , 0xFF , sizeof( r_RDd0FPageData));	SPI_WriteByte(ROM_SPI,_FCMD_READ_);		// ~50MHz	//SPI_WriteByte(ROM_SPI, _FCMD_FAST_READ_); 		// 50~104MHz	SPI_WriteByte(ROM_SPI,r_RDd0FPAddr[0]); 		// ADDRESS A23~16	SPI_WriteByte(ROM_SPI,r_RDd0FPAddr[1]); 		// ADDRESS A15~8	SPI_WriteByte(ROM_SPI,r_RDd0FPAddr[2]); 		// ADDRESS A7~0	//SPI_WriteByte(ROM_SPI, 0x00);   // Dummy (Only Fast Read)	for ( addr = 0 ; addr < _FData_Page ; addr ++)	{		r_RDd0FPageData[addr] = SPI_ReadByte(ROM_SPI);		//sprintf(uart2buf , "%d = 0x%02x", addr, r_RDd0FPageData[addr]);		//SendRS232(uart2buf);	}	delay_us(1);	INT_FLASH_CS(_INT_FLASH_CS_OFF_);	//delay_us(5);}void Load_Model_Description(void){
	#if 0	byte LMD_Index;	//word LMD_Index;	r_RDd0FPAddr[0] = 0x3F;	r_RDd0FPAddr[1] = 0xFF;	r_RDd0FPAddr[2] = 0x00;	FRead_Page_Serial_Flash();	//delay_ms(10);	// Load Model Name	//for (LMD_Index=0; LMD_Index<8; LMD_Index++)	for (LMD_Index=0; LMD_Index<9; LMD_Index++)	{		D_Model_Name[LMD_Index] = r_RDd0FPageData[LMD_Index];	}	// Load Check-Sum	D_Model_CS[0] = r_RDd0FPageData[16];	D_Model_CS[1] = r_RDd0FPageData[17];	// Load Program Description (Prog/Skip) = Unit: 64KB	for (LMD_Index=0; LMD_Index<31; LMD_Index++)	//for (LMD_Index=32; LMD_Index<31; LMD_Index++)	{		D_Model_Prog_Info[LMD_Index] = r_RDd0FPageData[(byte)(LMD_Index+32)];	}	// --> <y120424B>	// Load Model Description	for (LMD_Index=0; LMD_Index<32; LMD_Index++)	{		D_Model_Descript[LMD_Index] = r_RDd0FPageData[(byte)(LMD_Index+0x80)];	}	// 	// DEBUG OUTPUT	printf("Binary:%c%c%c%c%c%c%c%c%c\r\n", D_Model_Name[0],D_Model_Name[1],D_Model_Name[2],D_Model_Name[3],D_Model_Name[4],D_Model_Name[5],D_Model_Name[6],D_Model_Name[7], D_Model_Name[8]);	//sprintf(uart2buf , "CS:%x%x\r\n", D_Model_CS[0],D_Model_CS[1]);	//SendRS232(uart2buf);
	#endif }
void Write_Page_Flash_handler(void){	//printf("IF-Write: ");	FProg_Page_Serial_Flash();	printf("IF-Write: 0x%02x%02x\r\n", r_WRd0FPAddr[0], r_WRd0FPAddr[1]);}void Read_Page_Flash_handler(void){	//printf( "IF-Read: ");	FRead_Page_Serial_Flash();	printf("IF-Read: 0x%02x%02x\r\n", r_RDd0FPAddr[0], r_RDd0FPAddr[1]);}void Erase_Serial_Flash(void){	printf("Ers-F: ");	delay_us(10);	//outb(p_ROM_WP, 0);	FChip_Write_Enable();	FChip_Erase_Flash();	//delay_ms(1);	//Status = Check_Erase_Flash();	FChip_Write_Disable();	printf("  FINISH\r\n");	//outb(p_ROM_WP, 1);	delay_ms(1);	}void Init_Flash(void){ 	//130305 // outb(p_ROM_WP_IO, 1);	//GpioBPortInit(ROM_CS_PORT,ROM_CS_PIN,GPIO_Mode_OUT, GPIO_Speed_100MHz, GPIO_OType_PP, GPIO_PuPd_NOPULL );	uc_INT_FID[0] = 0;	uc_INT_FID[1] = 0;	uc_INT_FID[2] = 0;	INT_FLASH_SW_Reset_SEQ();	delay_ms(10);	FChip_Write_Enable();	delay_ms(10);	FWrite_Status_REG(_F_SRWD_WP_Diable_);	delay_ms(10);	INT_FLASH_READ_ID();	delay_ms(1);	Load_Model_Description();	//memset(r_RDd0FPageData , 0 , sizeof( r_RDd0FPageData));	//memset(r_WRd0FPageData , 0 , sizeof( r_WRd0FPageData));}